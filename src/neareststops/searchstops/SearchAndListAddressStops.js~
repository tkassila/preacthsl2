import React, { Component } from 'react';
import Address from '../Address.js';
import NearStop from './NearStop';
import axios from 'axios';
// import gql from "apollo-boost";

// import ApolloClient from "apollo-boost";
// import gql from "apollo-boost";
// import { withApollo } from 'react-apollo';
// import { url } from 'inspector';
// import { type } from 'os';

class SearchAndListAddressStops extends Component 
{
   // address_search_url = "https://api.digitransit.fi/geocoding/v1/search?text=";
    hsl_baseurl = null;
    // address_search_url = "http://localhost:8080/hsl/geocoding/v1/search?text=";
    address_search_url = null;
    prev_features = null;
  
    constructor(props) {
        super(props);
        console.log("SearchAndListAddressStops constructor(props)");
        console.log(this.props);
        this.hsl_baseurl = "http://localhost:8080/hsl/";
        this.address_search_url = this.hsl_baseurl +"geocoding/v1/search?text=";
        
        this.state = {
            searchstops: false,
            address: null,
            addressfeatures: null,
            neareststops: null,
	    distance: null
        }
     
        if (this.props.client)
        {
            this.client = this.props.client;
            console.log("SearchAndListAddressStops this.props.client");
        }

        if (this.client)
        console.log("client=" +this.client);
    else
        console.log("null: client" );

        if (this.props.address)
        {
            this.makeApolloCallForNearestStops(this.props.addressfeatures, this.props.distance);
            this.state = {
                searchstops: true,
                address: this.props.address,
                addressfeatures: this.props.addressfeatures,
		distance: this.props.distance
            }            
        }

      //  this.makeGetQuery();
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.address !== nextProps.address) {
          this.setState({address: nextProps.address});
        }
        if (this.props.addressfeatures !== nextProps.addressfeatures) {
            this.setState({addressfeatures: nextProps.addressfeatures});
          }
          if (this.props.addresssselected !== nextProps.addresssselected) {
            this.setState({addresssselected: nextProps.addresssselected});
          }  
          this.makeApolloCallForNearestStops(nextProps.addressfeatures)        
     }

     makeApolloCallForNearestStops(addressfeatures)
    {
        console.log("makeApolloCallForNearestStops 1 1" );
        console.log(addressfeatures );
        let coordinates = null;
        
        coordinates = addressfeatures.map((feature) => { return (feature && feature.geometry && feature.geometry.coordinates ? feature.geometry.coordinates : null); });
        console.log(coordinates );
        let longitude = coordinates[0][1];
        let latitude = coordinates[0][0];
        console.log("longitude ");
        console.log(longitude );
        console.log("latitude ");
        console.log(latitude );
        /*
        fetch('https://api.github.com/gists', {
    method: 'post',
    body: JSON.stringify({
        description: 'Fetch API Post example',
        public: true,
        files: {
          'test.js': {
            content: 'kissa'
          }
        }
      })
  }).then(function(response) {
    return response.json();
  }).then(function(data) {
    console.error('Created Gist:', data.html_url);
  });

  console.log("makeApolloCallForNearestStops 2" );
  */

  const options = {
    method: 'POST',
    data: `{
      stopsByRadius(lat:60.199,lon:24.938,radius:500) {
        edges {
          node {
            stop { 
              gtfsId 
              name
            }
            distance
          }
        }
      }
    }`,
    // credentials: 'include',
    headers: { "Content-Type": "application/graphql"}
  };
  
  let data = `{ stop(id: "HSL:1040129") {
    name
    lat
    lon
    wheelchairBoarding
  }  
}`;
  // let body = JSON.stringify(data);
  let body1 = `nearest(lat: 60.19414, lon: 25.02965, maxResults: 3, 
    trrt
  dddd
		      }`;
	
	// maxResults: 10,
  let body = `{ nearest(lat: ` +longitude +`, lon: ` +latitude +`,  
    maxDistance: ` +distance +`, filterByPlaceTypes: [STOP, BIKE_PARK]) {
    edges {
      node {
          place {
            lat
            lon
            ...on Stop {
              name
              gtfsId
              code
            }
            ...on BikePark {
              name
              bikeParkId
              spacesAvailable
            }
          }
          distance
      }
    }
  }
}`;
  console.log("body");
  console.log(body);

  // http://localhost:8080/hsl/geocoding/v1/search
  /*
  fetch( this.hsl_baseurl +'routing/v1/routers/hsl/index/graphql', {
    method: 'POST',
    */
 //   headers: {"Content-Type": "application/graphql",  'Accept': '*/*'},
  /*  body: body })
    .then(response => { return response.json();})
    .then(responseData => {console.log(responseData.data); return responseData.data;})
    .then(data => { 
      console.log("data");
      console.log(data); }
      )
    .catch((error) => {
        console.error("error");
        console.error(error);
    });
    */

   fetch( this.hsl_baseurl +'routing/v1/routers/hsl/index/graphql', {
    method: 'POST',
    headers: {"Content-Type": "application/graphql",  'Accept': '*/*'},
    body: body })
    .then(response => { return response.json();})
    .then(responseData => {console.log(responseData.data); return responseData.data;})
    .then(data => { 
      console.log("data");
      console.log(data);
      console.log(data.nearest.edges);
      this.setState({ neareststops: data.nearest.edges } ) }
      )
    .catch((error) => {
        console.error("error");
        console.error(error);
    });
  
/*
        fetch('http://localhost:8080/hsl/graphql/hsl', {
            method: 'post',
            headers: {"Content-Type": "application/graphql"},
            body: `{ stop(id: "HSL:1040129") {
                name
                lat
                lon
                wheelchairBoarding
              }  
            }`}
            ).then((response) => response.json())
           .then((responseJson) => {
            console.error("responseJson");
             return responseJson;
           })
           .catch((error) => {
            console.error("responseJson error");
             console.error(error);
           } );     
          */

           console.log("makeApolloCallForNearestStops 3" );
    }

     makeApolloCallForNearestStops2(addressfeatures)
     {
        console.log("makeApolloCallForNearestStops 2 1" );
        if (!addressfeatures)
            return;

            console.log("makeApolloCallForNearestStops before http CALL");

        // this.client.setUrl("https://api.digitransit.fi/graphql/hsl");
        /*
        this.client
            .query({
            query: gql`
            {
                stopsByRadius(lat:60.201706,lon:24.918506,radius:500) {
                  edges {
                    node {
                      stop { 
                        gtfsId 
                        name
                      }
                      distance
                    }
                  }
                }
            }        `
        })
      .then(result => console.log(result));
      */

      /*
     axios.post('https://api.digitransit.fi/graphql/hsl', { query: `{ 
        stopsByRadius(lat:60.201706,lon:24.918506,radius:1500) {
          edges {
            node {
              stop { 
                gtfsId 
                name
              }
              distance
            }
          }
        }
      }`,
      headers: { 'Content-Type': 'application/graphql' } })
      .then(function (response) {
        console.log("response");
        console.log(response);
      })
      .catch(function (error) {
        console.log("error");  
        console.log(error);
      });
      */

     var xhr = new XMLHttpRequest()
     //xhr.open("POST", 'https://api.digitransit.fi/graphql/hsl'  )
     xhr.open("POST", 'http://localhost:8080/hsl/graphql/hsl'  )
     xhr.setRequestHeader('Content-Type', 'application/graphql' );
     xhr.withCredentials = false;
     xhr.onload = function(e){
        console.log("onload=>");
       if (xhr.readyState === 4){
         if (xhr.status === 200){
            console.log("onload 1 =>");
           var data = JSON.parse(xhr.response);
           console.log("onload 2 =>");
           console.log("onload 3 data => " +data);
           /*
           this.setState({
             story: story,
             storyLength: story.length,
             currentChapter: story[0]
           })
           */
         } else {
           console.error(xhr.statusText)
         }
       }
     }; // .bind(this);
 
     xhr.onprogress = function () {
        console.log('LOADING', xhr.status);
    };
  
    xhr.onerror = function(e){
       console.error(xhr.statusText)
     };

     console.log("makeApolloCallForNearestStops before http CALL 2");

     xhr.send( `{ 
        stopsByRadius(lat:60.201706,lon:24.918506,radius:1500) {
          edges {
            node {
              stop { 
                gtfsId 
                name
              }
              distance
            }
          }
        }
      }`);
    

    console.log("makeApolloCallForNearestStops AFTER  http CALL");
    }

    /*
    componentDidMount() {
        this.makeGetQuery();
    }
    */

    /*
    componentDidUpdate()
    {
        this.makeGetQuery();
    }
    */

    makeGetQuery()
    {
        if (!this.props.searchstops && this.props.address.length == 0)
            return;
        if (this.props.address.length == 0)
            return;
        console.log("before: axios:" );
        const test = this.address_search_url +this.props.address;
        console.log("url:" +test  );
         const decodedurl = this.address_search_url +encodeURIComponent(this.props.address);
         console.log("decodedurl:" +decodedurl  );
        axios.get(decodedurl)
            .then(response => this.handleResponseData(response));
    }

    handleResponseData(response)
    {
            let i = 0;
            let bSearch = false;
            const features = response.data.features;
            let feature, coordinates, street;
            let bExactAdressFound = false;

            for (i in features) {
                feature = features[i];
                coordinates = feature.geometry.coordinates;
                street = feature.properties.name;            
                console.log("coordinates:" +coordinates);
                console.log("street:" +street);
                if (street != null && street.toString() == this.props.address.toString())
                {
                    bExactAdressFound = true;
                    console.log("bExactAdressFound:" +bExactAdressFound);
                    break;
                }
            } 

            if (bExactAdressFound)
            {
                console.log("bExactAdressFound2:" +bExactAdressFound);
                let addressfeature = new Object();
               if (this.props.address.length > 0)
                    bSearch = true;
                let afeatures = [ feature ];
                coordinates = feature.geometry.coordinates;
                street = feature.properties.name;
                this.setState({ searchstops: bSearch });
                this.setState( { addressfeatures: afeatures } );
            }
            else
            {
                console.log("features for 2:");
                /*
                for (i in features) {
                    feature = features[i];
                    coordinates = feature.geometry.coordinates;
                    street = feature.properties.name;            
                    console.log("coordinates:" +coordinates);
                    console.log("street:" +street);
                }     
                */
                if (this.props.address.length > 0)
                    bSearch = true;
                this.setState({ searchstops: bSearch });
                this.setState( { addressfeatures: features } );
       
            }
            //console.log(coordinates);
         //   this.render();
    }

    addresssSelected = (addressparam, distance) => {        
        console.log("addresssSelected.addressparam=" +addressparam);
        this.setState({
            address: addressparam,
            searchstops: false,
            addressfeatures: null,
	    distance: null
        });
        let bSearch = false;
    
        console.log("addressparam=" +addressparam);
        console.log("bSearch=" +bSearch);
	console.log("distance=" +distance);

	if (!distance || distance == '')
	    distance = '1500';

	this.setState({ ... this.state, distance: distance });
	
     //   React.render(this, document.getElementById('div.ListAddresses'));
       /* axios.get("https://api.digitransit.fi/geocoding/v1/search?text=kamppi&size=1")
        .then(response =>  console.log(response.data));
*/
//        then(response => this.setState({username: response.data.name}))
        console.log("bSearch2");
      }

    render() {
        const search = this.state.searchstops;
        console.log("rendering");
        console.log("search="+search);
        console.log(this.state.addressfeatures);
        // const features2 = this.state.addressfeatures;        
        let coordinates, street;
       if (search && this.state.addressfeatures /* && (this.prev_feature == null 
          || this.prev_feature != this.state.addressfeatures) */)
       {
           /*
           const features2 = this.state.addressfeatures.map((feature) => {
            return (
            <p>{feature.properties.name +" " +feature.geometry.coordinates}</p>
           );                    
           } 
        );
        */
            let childrenSize = this.state.addressfeatures.length;
            console.log("childrenSize:" +childrenSize);
            let children = this.state.addressfeatures;
            let features2 = this.state.addressfeatures.map((feature) => {
                return (
                  <Address address={feature.properties.name +" " +feature.geometry.coordinates} 
                  addresssselected={this.props.addresssselected}/>
               );                    
               } 
               );
               /*
            coordinates = feature.geometry.coordinates;
            street = feature.properties.name;            
            console.log("coordinates:" +coordinates);
            console.log("street:" +street);
            */
           console.log("this.state.neareststops:" +this.state.neareststops);
            let nearestopsmap = null;
            if (this.state.neareststops)
                nearestopsmap = this.state.neareststops.map((edge) => {
              return (
                <NearStop stop={edge.node} />
             );                    
             } 
             );
          //  if (!neareststops)
            this.prev_feature = this.state.addressfeatures;              
            return (
                <div>
                <p>{this.state.address}</p>
                {features2}
                {nearestopsmap}
                </div>
            );
       }
        else
        return (
            <div>
            </div>
        );
    }
}

//export default  withApollo(SearchAndListAddressStops);
export default  SearchAndListAddressStops;
